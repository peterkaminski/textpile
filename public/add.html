<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <title>Add Post · Textpile</title>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>
    <header>
      <a id="instance-name" class="instance-name" href="/">Textpile</a>
      <div class="actions">
        <a href="/">Home</a>
        <span class="separator" aria-hidden="true">&middot;</span>
        <a href="/about">About</a>
      </div>
    </header>

    <h1>Add Post</h1>

    <p class="small">
      Paste plain text or Markdown.<br>
      No author identity is collected. Posts expire automatically.<br>
      <a href="/about">Important use notes →</a>
    </p>

    <form id="form" class="row">
      <label>
        Title (optional)
        <input id="title" name="title" maxlength="140" placeholder="e.g. Analysis of recent developments" />
      </label>

      <label>
        Body (required)
        <div id="editor-preview-layout" class="editor-preview-layout">
          <div>
            <textarea id="body" name="body" placeholder="Paste Markdown or plain text here" required></textarea>
            <div class="small" id="size-info"></div>
          </div>

          <section id="preview-panel" class="card preview-panel" hidden>
            <div class="preview-header">
              <strong>Preview</strong>
              <span class="small">Preview approximates final rendering.</span>
            </div>
            <article id="preview-content" class="preview-content small">
              Preview is empty.
            </article>
          </section>
        </div>
      </label>

      <div class="actions preview-actions">
        <button type="button" id="preview-toggle-btn">Show Markdown preview</button>
        <div id="preview-mode-controls" class="preview-mode-controls" hidden>
          <button type="button" class="preview-mode-btn active" data-mode="split" aria-pressed="true">Split</button>
          <button type="button" class="preview-mode-btn" data-mode="edit" aria-pressed="false">Edit only</button>
          <button type="button" class="preview-mode-btn" data-mode="preview" aria-pressed="false">Preview only</button>
        </div>
      </div>

      <label>
        Retention period (required)
        <select id="expiry" name="expiry" required>
          <option value="1week">1 week</option>
          <option value="1month">1 month</option>
          <option value="3months">3 months</option>
          <option value="6months">6 months</option>
          <option value="1year">1 year</option>
        </select>
      </label>

      <p class="small">
        <strong>Important:</strong> Posts expire automatically after the selected period. Textpile does not back up content. Keep your own copy!
      </p>

      <div class="actions">
        <button type="submit" id="btn">Publish</button>
        <span id="msg" class="small"></span>
      </div>

      <hr />

      <details>
        <summary class="small">Optional: add post password</summary>
        <p class="small">
          If the site owner has enabled an add post password, paste it here. Otherwise leave blank.
        </p>
        <input id="token" name="token" placeholder="add post password (if required)" />
      </details>
    </form>

    <script type="module">
      import { initPage, getConfig } from '/textpile-utils.js';

      // Initialize page (load config, apply community name, update page title, add footer)
      await initPage({ pageTitle: "Add Post" });

      // Set default retention from config
      const defaultRetention = getConfig('defaultRetention');
      const expirySelect = document.getElementById("expiry");
      if (defaultRetention && expirySelect) {
        const option = expirySelect.querySelector(`option[value="${defaultRetention}"]`);
        if (option) {
          option.selected = true;
        }
      }

      const form = document.getElementById("form");
      const msg = document.getElementById("msg");
      const btn = document.getElementById("btn");
      const bodyField = document.getElementById("body");
      const sizeInfo = document.getElementById("size-info");
      const previewToggleBtn = document.getElementById("preview-toggle-btn");
      const previewModeControls = document.getElementById("preview-mode-controls");
      const previewModeButtons = Array.from(document.querySelectorAll(".preview-mode-btn"));
      const editorPreviewLayout = document.getElementById("editor-preview-layout");
      const previewPanel = document.getElementById("preview-panel");
      const previewContent = document.getElementById("preview-content");

      let previewEnabled = false;
      let previewMode = "split";
      let previewLoadPromise = null;
      let previewRenderTimer = null;

      // Size limits (hardcoded to match server defaults)
      const MAX_SIZE = 1048576; // 1 MB
      const WARN_SIZE = 786432; // 750 KB

      function updateSizeInfo() {
        const text = bodyField.value;
        const size = new Blob([text]).size;
        const sizeMB = (size / 1048576).toFixed(2);
        const sizeKB = (size / 1024).toFixed(1);

        if (size > MAX_SIZE) {
          sizeInfo.innerHTML = `<span style="color: #f44336;">⚠️ Too large: ${sizeMB} MB (max 1 MB)</span>`;
          btn.disabled = true;
        } else if (size > WARN_SIZE) {
          sizeInfo.innerHTML = `<span style="color: #ff9800;">⚠️ Warning: ${sizeKB} KB (approaching 1 MB limit)</span>`;
          btn.disabled = false;
        } else {
          sizeInfo.textContent = `Size: ${sizeKB} KB`;
          btn.disabled = false;
        }
      }

      function updatePreviewModeButtons() {
        previewModeButtons.forEach((button) => {
          const active = button.dataset.mode === previewMode;
          button.classList.toggle("active", active);
          button.setAttribute("aria-pressed", active ? "true" : "false");
        });
      }

      function updatePreviewLayout() {
        editorPreviewLayout.classList.toggle("split", previewEnabled && previewMode === "split");
        editorPreviewLayout.classList.toggle("edit-only", previewEnabled && previewMode === "edit");
        editorPreviewLayout.classList.toggle("preview-only", previewEnabled && previewMode === "preview");
        previewPanel.hidden = !previewEnabled;
        previewModeControls.hidden = !previewEnabled;
        previewToggleBtn.textContent = previewEnabled ? "Hide Markdown preview" : "Show Markdown preview";
        updatePreviewModeButtons();
      }

      function loadMarked() {
        if (window.marked && typeof window.marked.parse === "function") {
          return Promise.resolve(window.marked);
        }

        if (previewLoadPromise) {
          return previewLoadPromise;
        }

        previewLoadPromise = new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = "https://cdn.jsdelivr.net/npm/marked/marked.min.js";
          script.async = true;
          script.onload = () => {
            if (window.marked && typeof window.marked.parse === "function") {
              resolve(window.marked);
            } else {
              reject(new Error("Markdown parser loaded, but preview is unavailable."));
            }
          };
          script.onerror = () => {
            previewLoadPromise = null;
            reject(new Error("Failed to load Markdown preview engine."));
          };
          document.head.appendChild(script);
        });

        return previewLoadPromise;
      }

      async function renderPreviewNow() {
        if (!previewEnabled) return;

        const raw = bodyField.value;
        if (!raw.trim()) {
          previewContent.textContent = "Preview is empty.";
          return;
        }

        try {
          const marked = await loadMarked();
          previewContent.innerHTML = marked.parse(raw);
        } catch (err) {
          previewContent.textContent = String(err.message || err);
        }
      }

      function renderPreviewDebounced() {
        if (!previewEnabled) return;
        clearTimeout(previewRenderTimer);
        previewRenderTimer = setTimeout(() => {
          renderPreviewNow();
        }, 150);
      }

      bodyField.addEventListener("input", updateSizeInfo);
      bodyField.addEventListener("input", renderPreviewDebounced);
      updateSizeInfo();

      previewToggleBtn.addEventListener("click", () => {
        previewEnabled = !previewEnabled;
        updatePreviewLayout();
        if (previewEnabled) {
          renderPreviewNow();
        }
      });

      previewModeButtons.forEach((button) => {
        button.addEventListener("click", () => {
          previewMode = button.dataset.mode || "split";
          updatePreviewLayout();
          renderPreviewNow();
        });
      });

      updatePreviewLayout();

      form.addEventListener("submit", async (e) => {
        e.preventDefault();
        msg.textContent = "";
        btn.disabled = true;

        const title = document.getElementById("title").value.trim();
        const body = document.getElementById("body").value.trim();
        const expiry = document.getElementById("expiry").value;
        const token = document.getElementById("token").value.trim();

        // Client-side validation
        if (!body) {
          msg.textContent = "Body is required.";
          btn.disabled = false;
          return;
        }

        try {
          const res = await fetch("/api/add", {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({
              title: title || null,
              body,
              expiry,
              token: token || null
            })
          });

          const data = await res.json().catch(() => ({}));
          if (!res.ok) {
            throw new Error(data?.error || `Add failed: ${res.status}`);
          }

          msg.textContent = "Published. Redirecting…";
          window.location.href = data.url;
        } catch (err) {
          msg.textContent = String(err.message || err);
        } finally {
          btn.disabled = false;
        }
      });
    </script>
  </body>
</html>
